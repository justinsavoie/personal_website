<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jeu du dictionnaire</title>
    <style>
        /* --- Styles Généraux --- */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f4f7f6;
            color: #333;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        .game-container {
            width: 100%;
            max-width: 700px;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.1);
            padding: 30px 40px;
            box-sizing: border-box;
        }

        h1, h2, h3, h4 {
            text-align: center;
            color: #2c3e50;
        }
        
        h1 { margin-bottom: 10px; }
        h2 { font-style: italic; font-weight: 500; color: #e74c3c; margin-top: 0; margin-bottom: 30px; }
        h4 { text-align: left; margin-bottom: 10px; border-bottom: 1px solid #eee; padding-bottom: 5px;}

        p { line-height: 1.6; }

        /* --- Styles du Dashboard --- */
        #dashboard {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 15px 20px;
            margin-bottom: 25px;
            border: 1px solid #e9ecef;
        }
        #dashboard h3 { margin-top: 0; margin-bottom: 10px; font-size: 1.2em; text-align: left; }
        #scoreboard { list-style: none; padding: 0; margin: 0; }
        #scoreboard li { display: flex; justify-content: space-between; padding: 8px 0; font-size: 1.1em; border-bottom: 1px solid #e9ecef; }
        #scoreboard li:last-child { border-bottom: none; }
        #scoreboard li.human-player { font-weight: bold; color: #3498db; }
        #scoreboard .player-name { font-weight: 500; }
        #scoreboard .player-score { font-weight: bold; }

        /* --- Styles des Vues du Jeu --- */
        .game-view { display: none; }
        #start-screen { display: block; text-align: center; }
        
        #game-header {
            text-align: center;
            border-bottom: 2px solid #eee;
            padding-bottom: 15px;
            margin-bottom: 20px;
        }
        #game-header h3 { margin: 0; }

        /* --- Styles des Éléments d'Interface --- */
        button, .button-link {
            display: block; width: 100%; padding: 15px; font-size: 1.1em; font-weight: bold;
            color: white; border: none; border-radius: 8px;
            cursor: pointer; transition: background-color 0.2s, opacity 0.2s; 
            text-align: center; text-decoration: none; box-sizing: border-box;
        }
        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
            opacity: 0.7;
        }
        #start-button {
            background-color: #3498db;
            margin-top: 20px;
        }
        #start-button:hover:not(:disabled) { background-color: #2980b9; }
        
        #back-to-playground-button {
            background-color: #e74c3c;
            margin-top: 10px;
        }
        #back-to-playground-button:hover { background-color: #c0392b; }

        #submit-definition-button, #voting-form button, #next-round-button {
            background-color: #3498db; margin-top: 20px;
        }
        #submit-definition-button:hover, #voting-form button:hover, #next-round-button:hover { background-color: #2980b9; }

        #restart-button-ingame {
            background-color: #e74c3c;
            margin: 0 0 15px 0;
            padding: 12px;
            font-size: 1em;
        }
        #restart-button-ingame:hover { background-color: #c0392b; }

        /* Bouton explications */
        #show-explanation-button {
            background-color: #7f8c8d;
            font-size: 0.9em;
            padding: 12px;
            margin-top: 15px;
        }
        #show-explanation-button:hover { background-color: #95a5a6; }

        textarea { width: 100%; height: 100px; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-size: 1em; box-sizing: border-box; resize: vertical; }
        .definitions-list { list-style: none; padding: 0; }
        .definitions-list li { background-color: #ecf0f1; padding: 15px; margin-bottom: 10px; border-radius: 8px; cursor: pointer; transition: background-color 0.2s, box-shadow 0.2s; border: 2px solid transparent; }
        .definitions-list li label { display: flex; align-items: center; cursor: pointer; }
        .definitions-list input[type="radio"] { margin-right: 15px; transform: scale(1.4); }

        /* --- Styles pour les Résultats --- */
        #results-list li { opacity: 0.7; padding-left: 20px; position: relative; }
        #results-list li.correct-answer { background-color: #e8f5e9; border-color: #2ecc71; opacity: 1; font-weight: bold; }
        #results-list li.user-submission { background-color: #e3f2fd; }
        #results-list .votes-display { font-size: 0.9em; font-style: italic; color: #7f8c8d; margin-top: 8px; padding-left: 5px; border-left: 3px solid #bdc3c7; }
        
        #round-summary ul { list-style-type: none; padding-left: 0; }
        #round-summary li { background-color: #f8f9fa; padding: 8px 12px; border-radius: 4px; margin-bottom: 5px; font-size: 0.95em; }
        #round-summary strong { color: #34495e; }

        /* Modale */
        .modal {
            display: none; position: fixed; z-index: 1000; left: 0; top: 0;
            width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6);
            align-items: center; justify-content: center;
        }
        .modal-content {
            background-color: #fefefe; margin: auto; padding: 25px 30px; border: 1px solid #888;
            width: 90%; max-width: 600px; border-radius: 10px; position: relative;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .modal-content ul { list-style-type: none; padding: 0; }
        .modal-content li { margin-bottom: 10px; font-size: 0.95em; padding-bottom: 10px; border-bottom: 1px solid #eee; }
        .modal-content li:last-child { border-bottom: none; }
        .modal-content .score { font-weight: bold; color: #2980b9; }
        .close-button {
            color: #aaa; float: right; font-size: 28px; font-weight: bold;
            position: absolute; top: 10px; right: 20px; cursor: pointer;
        }
        .close-button:hover, .close-button:focus { color: black; }
    </style>
</head>
<body>
    <div class="game-container">
        <div id="start-screen" class="game-view">
            <h1>Jeu du dictionnaire</h1>
            <p>
                Le but est simple : un mot compliqué vous est présenté. Inventez une fausse définition crédible
                qui sera mélangée à la vraie et à des leurres. Votez pour la définition que vous pensez être la bonne
                et essayez de tromper les joueurs IA. <strong>Vous ne pouvez pas voter pour votre propre définition.</strong>
            </p>
            <p>
                Pour plus d'info sur la méthodologie : 
            <a href="../../blog/le-jeu-du-dictionnaire.html">Le jeu du dictionnaire</a>.
            </p>    
            </p>
            <button id="start-button" disabled>Chargement...</button>
            <a href="/#playground" id="back-to-playground-button" class="button-link">Retourner au Playground</a>
        </div>

        <div id="game-screen" class="game-view">
            <div id="dashboard">
                <button id="restart-button-ingame">Retourner à l'accueil</button>
                <h3>Tableau des scores</h3>
                <ul id="scoreboard"></ul>
            </div>
            <div id="game-header"><h3>Le mot du tour est :</h3></div>
            <h2 id="word-display"></h2>
            <div id="definition-input-view">
                <p>Inventez une définition pour ce mot. Soyez créatif et crédible !</p>
                <textarea id="user-definition" placeholder="Écrivez votre définition ici..."></textarea>
                <button id="submit-definition-button">Soumettre ma définition</button>
            </div>
            <div id="voting-view" class="game-view">
                <p>Votez pour la définition que vous pensez être la bonne (pas la vôtre) :</p>
                <form id="voting-form">
                    <ul id="definitions-to-vote" class="definitions-list"></ul>
                    <button type="submit">Voter</button>
                </form>
            </div>
            <div id="results-view" class="game-view">
                <h4>Votes de la manche :</h4>
                <ul id="results-list" class="definitions-list"></ul>
                <div id="round-summary"></div>
                <button id="next-round-button">Manche Suivante</button>
                <button id="show-explanation-button">Voir les explications sur le vote</button>
            </div>
        </div>
        
        <div id="end-screen" class="game-view">
            <h1>Fin de la partie !</h1>
            <p id="final-score"></p>
            <button id="restart-button-end" class="button-link">Retourner à l'accueil</button>
        </div>
    </div>

    <div id="explanation-modal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <div id="explanation-content"></div>
        </div>
    </div>

    <script>
/* ------------------------ Données & Logique du jeu ------------------------ */
let VRAIES_DEFINITIONS = [];
let FAUSSES_DEFINITIONS = [];
let wordToVectorMap = null;

/* --- Utilitaires --- */
function shuffleArray(array) {
    const arr = array.slice();
    for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
}

const VectorMath = {
    dot: (v1, v2) => v1.reduce((acc, val, i) => acc + val * v2[i], 0),
    norm: (v) => Math.sqrt(v.reduce((acc, val) => acc + val * val, 0)),
    cosineSimilarity: (v1, v2) => {
        const n1 = VectorMath.norm(v1);
        const n2 = VectorMath.norm(v2);
        if (n1 === 0 || n2 === 0) return 0;
        return VectorMath.dot(v1, v2) / (n1 * n2);
    }
};

function getSentenceVector(sentence) {
    if (!wordToVectorMap) return null;
    const tokens = (sentence.toLowerCase().match(/\b\w+\b/g) || []);
    const vectors = tokens.map(t => wordToVectorMap[t]).filter(Boolean);
    if (vectors.length === 0) return null;
    const len = vectors[0].length;
    const mean = new Array(len).fill(0);
    for (const vec of vectors) {
        for (let i = 0; i < len; i++) mean[i] += vec[i];
    }
    return mean.map(v => v / vectors.length);
}

/* --- DOM --- */
const startScreen = document.getElementById('start-screen');
const gameScreen = document.getElementById('game-screen');
const endScreen = document.getElementById('end-screen');
const wordDisplay = document.getElementById('word-display');
const scoreboard = document.getElementById('scoreboard');
const finalScoreDisplay = document.getElementById('final-score');
const definitionInputView = document.getElementById('definition-input-view');
const userDefinitionInput = document.getElementById('user-definition');
const votingView = document.getElementById('voting-view');
const votingForm = document.getElementById('voting-form');
const definitionsToVoteList = document.getElementById('definitions-to-vote');
const resultsView = document.getElementById('results-view');
const resultsList = document.getElementById('results-list');
const roundSummary = document.getElementById('round-summary');
const startButton = document.getElementById('start-button');
const submitDefinitionButton = document.getElementById('submit-definition-button');
const nextRoundButton = document.getElementById('next-round-button');
const restartButtonEnd = document.getElementById('restart-button-end');
const restartButtonIngame = document.getElementById('restart-button-ingame');
const showExplanationButton = document.getElementById('show-explanation-button');
const explanationModal = document.getElementById('explanation-modal');
const explanationContent = document.getElementById('explanation-content');
const closeModalButton = document.querySelector('.close-button');

/* --- État du jeu --- */
let playerScores = {};
let usedWordIndexes = new Set();
let currentWord = {};
let definitionsForRound = [];

// Réglages
const FAKE_PLAYERS_COUNT = 3;
const DECOY_COUNT = 4; // indépendant du nombre d'IA
const PLAYER_NAMES = ['Vous'];

function updateDashboard() {
    scoreboard.innerHTML = '';
    const names = [...PLAYER_NAMES];
    names.forEach((name, idx) => {
        const li = document.createElement('li');
        if (idx === 0) li.classList.add('human-player');
        const left = document.createElement('span'); left.className = 'player-name'; left.textContent = name;
        const right = document.createElement('span'); right.className = 'player-score'; right.textContent = playerScores[name] ?? 0;
        li.appendChild(left); li.appendChild(right); scoreboard.appendChild(li);
    });
}

function initializePlayerNames() {
    if (PLAYER_NAMES.length === 1) {
        for (let i = 0; i < FAKE_PLAYERS_COUNT; i++) PLAYER_NAMES.push(`Joueur ${i + 1}`);
    }
}

function startGame() {
    initializePlayerNames();
    playerScores = {};
    PLAYER_NAMES.forEach(n => playerScores[n] = 0);
    usedWordIndexes.clear();
    updateDashboard();
    startScreen.style.display = 'none';
    endScreen.style.display = 'none';
    gameScreen.style.display = 'block';
    startNewRound();
}

function endGame() {
    gameScreen.style.display = 'none';
    endScreen.style.display = 'block';
    const entries = Object.entries(playerScores).sort((a,b) => b[1]-a[1]);
    const lines = entries.map(([n,s]) => `${n}: ${s} pts`).join('\n');
    finalScoreDisplay.textContent = lines;
}

function startNewRound() {
    if (VRAIES_DEFINITIONS.length === 0) return;
    if (usedWordIndexes.size >= VRAIES_DEFINITIONS.length) { endGame(); return; }
    let idx;
    do { idx = Math.floor(Math.random() * VRAIES_DEFINITIONS.length); } while (usedWordIndexes.has(idx));
    usedWordIndexes.add(idx);
    currentWord = VRAIES_DEFINITIONS[idx];
    wordDisplay.textContent = currentWord.mot;
    userDefinitionInput.value = '';
    resultsView.style.display = 'none';
    votingView.style.display = 'none';
    definitionInputView.style.display = 'block';
}

function displayVotingOptions() {
    definitionsToVoteList.innerHTML = '';
    definitionsForRound.forEach((def, index) => {
        const li = document.createElement('li');
        const label = document.createElement('label');
        const radio = document.createElement('input');
        radio.type = 'radio';
        radio.name = 'vote';
        radio.value = index.toString();
        if (def.author === 'Vous') radio.disabled = true; // pas d'auto-vote humain
        const span = document.createElement('span'); span.textContent = def.text;
        label.appendChild(radio); label.appendChild(span);
        li.appendChild(label); definitionsToVoteList.appendChild(li);
    });
}

function handleSubmitDefinition() {
    const userSubmission = (userDefinitionInput.value || '').trim();
    if (!userSubmission) { alert('Veuillez entrer une définition.'); return; }

    definitionsForRound = [
        { text: currentWord.definition, isReal: true,  author: 'Dictionnaire' },
        { text: userSubmission,         isReal: false, author: 'Vous' }
    ];

    // Découpler le nombre de leurres du nombre d'IA
    const decoyPool = shuffleArray(FAUSSES_DEFINITIONS);
    const useCount = Math.min(DECOY_COUNT, decoyPool.length);
    for (let i = 0; i < useCount; i++) {
        const txt = decoyPool[i];
        // Attribuer aux IA existantes d'abord, sinon "Anonyme X"
        const aiName = PLAYER_NAMES[i + 1] || `Anonyme ${i + 1}`;
        definitionsForRound.push({ text: txt, isReal: false, author: aiName });
    }

    // Si on manque de leurres, ajouter des placeholders simples pour éviter les erreurs
    if (useCount < DECOY_COUNT) {
        for (let i = useCount; i < DECOY_COUNT; i++) {
            const aiName = PLAYER_NAMES[i + 1] || `Anonyme ${i + 1}`;
            definitionsForRound.push({ text: '(leurre manquant)', isReal: false, author: aiName });
        }
    }

    definitionsForRound = shuffleArray(definitionsForRound);
    definitionInputView.style.display = 'none';
    votingView.style.display = 'block';
    displayVotingOptions();
}

function aiVotesAndResults(userVoteIndex) {
    const realVec = getSentenceVector(currentWord.definition);
    const baseScores = definitionsForRound.map(d => {
        const v = getSentenceVector(d.text);
        if (!realVec || !v) return 0;
        return VectorMath.cosineSimilarity(realVec, v);
    });

    const votes = [];
    // Vote humain
    votes.push({ voter: 'Vous', choice: userVoteIndex });

    // Votes des IA: meilleur score avec petite noise, sans auto-vote
    for (let i = 0; i < FAKE_PLAYERS_COUNT; i++) {
        const voterName = `Joueur ${i + 1}`;
        // noise légère pour réduire l'effet "meute"
        const scores = baseScores.map(s => s + (Math.random() * 0.02 - 0.01));

        let best = -Infinity; 
        let bestIdx = -1;
        for (let j = 0; j < scores.length; j++) {
            const def = definitionsForRound[j];
            if (def.author === voterName) continue; // pas d'auto-vote IA
            if (scores[j] > best) { best = scores[j]; bestIdx = j; }
        }
        // Fallback si tout était interdit (ne devrait pas arriver) : choisir au hasard un index autorisé
        if (bestIdx === -1) {
            const allowed = definitionsForRound
                .map((d, idx) => ({ d, idx }))
                .filter(x => x.d.author !== voterName);
            const pick = allowed[Math.floor(Math.random() * allowed.length)];
            bestIdx = pick ? pick.idx : 0;
        }
        votes.push({ voter: voterName, choice: bestIdx });
    }

    // Scores: +2 pour un vote correct; +1 par vote reçu (hors dictionnaire)
    const receivedVotes = new Array(definitionsForRound.length).fill(0);
    votes.forEach(v => receivedVotes[v.choice]++);
    votes.forEach(v => {
        const def = definitionsForRound[v.choice];
        if (def.isReal) { playerScores[v.voter] = (playerScores[v.voter] || 0) + 2; }
    });
    definitionsForRound.forEach((def, idx) => {
        const count = receivedVotes[idx];
        if (count > 0 && def.author !== 'Dictionnaire') {
            playerScores[def.author] = (playerScores[def.author] || 0) + count;
        }
    });

    // Rendu résultats
    resultsList.innerHTML = '';
    definitionsForRound.forEach((def, idx) => {
        const li = document.createElement('li');
        if (def.isReal) li.classList.add('correct-answer');
        if (def.author === 'Vous') li.classList.add('user-submission');
        li.textContent = def.text;
        const votesDiv = document.createElement('div'); votesDiv.className = 'votes-display';
        const who = votes.filter(v => v.choice === idx).map(v => v.voter).join(', ');
        votesDiv.textContent = `Votes: ${receivedVotes[idx]}${who ? ` (${who})` : ''}`;
        li.appendChild(votesDiv); resultsList.appendChild(li);
    });

    roundSummary.innerHTML = '';
    const ul = document.createElement('ul');
    definitionsForRound.forEach(def => {
        const li = document.createElement('li');
        li.innerHTML = `<strong>${def.author}</strong>: ${def.isReal ? 'Définition correcte' : 'Définition proposée'}`;
        ul.appendChild(li);
    });
    roundSummary.appendChild(ul);

    updateDashboard();
}

/* --- Événements --- */
startButton.addEventListener('click', startGame);
submitDefinitionButton.addEventListener('click', handleSubmitDefinition);
votingForm.addEventListener('submit', (e) => {
    e.preventDefault();
    const selected = votingForm.querySelector('input[name="vote"]:checked');
    if (!selected) { alert('Veuillez choisir une définition.'); return; }
    const idx = parseInt(selected.value, 10);
    votingView.style.display = 'none';
    resultsView.style.display = 'block';
    aiVotesAndResults(idx);
});
nextRoundButton.addEventListener('click', () => { startNewRound(); });
restartButtonEnd.addEventListener('click', () => { startScreen.style.display = 'block'; endScreen.style.display = 'none'; });
restartButtonIngame.addEventListener('click', () => { startScreen.style.display = 'block'; gameScreen.style.display = 'none'; });
showExplanationButton.addEventListener('click', () => {
    explanationContent.innerHTML = '<p>Les joueurs IA choisissent la définition la plus proche de la vraie (similarité cosinus sur des embeddings de mots), avec une légère variabilité, et <strong>sans auto-vote</strong>. Points : +2 si vous votez juste, +1 par vote reçu sur votre définition.</p>';
    explanationModal.style.display = 'flex';
});
closeModalButton.addEventListener('click', () => { explanationModal.style.display = 'none'; });
window.addEventListener('click', (e) => { if (e.target === explanationModal) explanationModal.style.display = 'none'; });

/* --- Chargement des données --- */
async function loadAssets() {
    try {
        const [embRes, vraiesRes, faussesRes] = await Promise.all([
            fetch('assets/word_embeddings.json'),
            fetch('assets/vraies_definitions.json'),
            fetch('assets/fausses_definitions.json')
        ]);
        const [emb, vraies, fausses] = await Promise.all([
            embRes.json(), vraiesRes.json(), faussesRes.json()
        ]);

        // Construire la map des embeddings
        wordToVectorMap = Array.isArray(emb)
            ? emb.reduce((map, item) => { 
                if (item && item.word && Array.isArray(item.vector)) map[item.word] = item.vector; 
                return map; 
              }, {})
            : emb; // si déjà sous forme map

        VRAIES_DEFINITIONS = Array.isArray(vraies) ? vraies : [];
        FAUSSES_DEFINITIONS = Array.isArray(fausses) ? fausses : [];

        if (!VRAIES_DEFINITIONS.length) throw new Error('Aucune vraie définition chargée.');
        if (!Object.keys(wordToVectorMap || {}).length) console.warn('Embeddings absents ou vides — similarités = 0.');

        startButton.disabled = false;
        startButton.textContent = 'Commencer une partie';
    } catch (err) {
        console.error('Erreur de chargement des assets:', err);
        startButton.textContent = 'Erreur de chargement';
    }
}

// Démarrer le chargement
loadAssets();
    </script>
    
    </body>
    </html>
